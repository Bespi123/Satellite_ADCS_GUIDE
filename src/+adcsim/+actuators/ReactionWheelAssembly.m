classdef ReactionWheelAssembly
    % REACTIONWHEELASSEMBLY Models a complete assembly of N reaction wheels.
    % * This class manages the state, control, and dynamics for a set of
    % * reaction wheels in a fully vectorized manner for high-performance simulation.

    properties (SetAccess = public)
        States          % State matrix [2 x N_rw], where row 1 is speed, row 2 is current
        NumWheels       % The number of reaction wheels (N)
        MotorParams     % Struct with SCALAR motor parameters (Jrw, kt, R, etc.)
        voltage_vector  % Voltage input for motors
    end
    
    properties (Access = private)
        % Internal states for the vectorized PID controller
        pid_Kp
        pid_Ki
        pid_Kd
        pid_N
        pid_IntegratorState
        pid_DifferentiatorState
        pid_LastError
    end

    methods
        function obj = ReactionWheelAssembly(rw)
            % Constructor: Creates the assembly for N reaction wheels.
            obj.NumWheels   = rw.number;
            obj.MotorParams = rw.motor;
            
            % Initialize state matrix for N wheels
            obj.States = zeros(2, obj.NumWheels);
            obj.voltage_vector = zeros(obj.NumWheels,1);

            % Initialize PID controller parameters and states
            pid_params = rw.motor.pid;
            obj.pid_Kp = pid_params.kp;
            obj.pid_Ki = pid_params.ki;
            obj.pid_Kd = pid_params.kd;
            obj.pid_N  = pid_params.Nu;
            
            % Initialize arrays to store last states
            obj.pid_IntegratorState     = zeros(1, obj.NumWheels);
            obj.pid_DifferentiatorState = zeros(1, obj.NumWheels);
            obj.pid_LastError           = zeros(1, obj.NumWheels);
        end

        function [obj, torque_real_vector] = update(obj, speed_cmd_vector, dt)
            % update: Simulates the dynamics of all motors for one time step.
            
            % 1. Get the current speed of all wheels (1xN row vector)
            current_speed_vector = obj.States(1, :);
            
            % 2. Calculate the speed error for all wheels
            speed_error_vector = speed_cmd_vector(:)' - current_speed_vector;
            
            % 3. The PID calculates the required input voltage for ALL wheels at once
            [obj, obj.voltage_vector] = obj.calculatePID(speed_error_vector, dt);

            % 4. Integrate the motor dynamics (RK4) for all wheels simultaneously
            currentStateMatrix = obj.States; % [2 x N]
            
            g1 = dt * obj.brushlessModelMatrix(currentStateMatrix, obj.voltage_vector);
            g2 = dt * obj.brushlessModelMatrix(currentStateMatrix + 0.5 * g1, obj.voltage_vector);
            g3 = dt * obj.brushlessModelMatrix(currentStateMatrix + 0.5 * g2, obj.voltage_vector);
            g4 = dt * obj.brushlessModelMatrix(currentStateMatrix + g3, obj.voltage_vector);
            
            newStateMatrix = currentStateMatrix + (1/6) * (g1 + 2*g2 + 2*g3 + g4);
            
            % 5. Calculate the real torque generated by each wheel from the acceleration
            angular_acceleration_vector = (newStateMatrix(1, :) - current_speed_vector) / dt;
            torque_real_vector = obj.MotorParams.Jrw * angular_acceleration_vector;
            
            % 6. Update the state of the entire assembly
            obj.States = newStateMatrix;
        end
    end

    methods (Access = private)
        function [obj, u_vector] = calculatePID(obj, error_vector, dt)
            % Vectorized PID controller calculation.
            
            % Integral term
            obj.pid_IntegratorState = obj.pid_IntegratorState + error_vector * dt;
            
            % Derivative term with filter
            error_dot_vector = (error_vector - obj.pid_LastError) / dt;

            % 4. Implement derivative filter with Runge-Kutta (4th order)
            % For surge velocity:
            k1 = obj.pid_N * (error_dot_vector - obj.pid_DifferentiatorState);
            k2 = obj.pid_N * (error_dot_vector - (obj.pid_DifferentiatorState + k1*dt/2));
            k3 = obj.pid_N * (error_dot_vector - (obj.pid_DifferentiatorState + k2*dt/2));
            k4 = obj.pid_N * (error_dot_vector - (obj.pid_DifferentiatorState + k3*dt));
            obj.pid_DifferentiatorState = obj.pid_DifferentiatorState + (k1 + 2*k2 + 2*k3 + k4)*dt/6;
            
            % Control output for all wheels
            u_vector = obj.pid_Kp * error_vector + obj.pid_Ki * obj.pid_IntegratorState + obj.pid_Kd * obj.pid_DifferentiatorState;
            
            % Update state for the next iteration
            obj.pid_LastError = error_vector;
        end

        function dx = brushlessModelMatrix(obj, x, u)
            % Vectorized brushless motor model for N wheels.
            
            % Unpack state vectors (1xN rows)
            w = x(1, :); % [rad/s] Angular velocity
            i = x(2, :); % [A] Current
            
            % Unpack scalar parameters
            p = obj.MotorParams;
            
            % Calculate derivatives for all wheels using element-wise operations
            w_dot = (1/p.Jrw) * (p.kt * i - p.b * w - p.c * sign(w));
            i_dot = (1/p.L)  * (u - p.R * i - p.ke * w);
            
            % Assemble the derivative matrix
            dx = [w_dot; i_dot];
        end
    end
end